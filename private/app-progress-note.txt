tileGridSetting: {
  numberOfRow: 
  numberOfColumn:
  rowHeight:
  columnWidth:
  gutter???
}

class Tile {
  // props
  x
  y
  speedY??
  number

  links = {
    top:
    bottom:
    left:  
    right: null / Tile
  }

  boundary?? 
  //methods

  render() {render an element based on current x, y, and speedY. result shown after next animation frame}
  

}

gameArea = {
  x? <inGameCursor>
  y? <inGameCursor>, changed every mouse move over window. it's still changed even after the cursor leaves canvas.
  canvasElement:
  tileGrid?
  canvasContext: can i immediately access the canvasElement directly?
  start:
  clear:

  grabTile() {
    the thing that needs to be noticed is that the window cursor should be in there too. use window.addEL for onmousemove, use canvas.addEl for onmousedown.


    determines which tile is clicked over. it uses (probably) tileGrid based on current ingame cursor. it also check if that tile is already in cursor position, if not, do nothing. it also check tile above and below it because there is a chance that the tile is already modeled below it. 

    grabTile should also automatically move tile to the position it should be.

    alse check if that tile is actually grabable. grabable tile the tile that is not falling, or it's falling but it's on the top stack.

    this function highly dependent on tileGrid. it's accuracy is extremely important to prevent unintended bugs.
  }
  getXYPosition() {
    returns array of [this.x, this.y]; // array or tuple?
  }
  getRowColumnPosition() {
    return [row,col] based on current this.x, this.y 
  }
  isGrabable() {
    check if that tile is actually grabable. grabable tile the tile that is not falling, or it's falling but it's on the top stack. 

    I should notice that grabbing element that is going to combine while falling can cause the problem if I have already delete that combined element from the 
  }
  
}




moveTile() {

}


moveTile() {
  // case 1: just clicked to grouped tile
  1. get all tile linked to this tile.
  2. we need the data about the position of other linked data.  
  3. the rendered position depends on boundary condition. create a position about boundary condition.
  // case 2: the grid position is changed
  4. update tileGrid
  // case 3: sudden position change
  5. determineNewPosiiton


  what if we encounter same tile grid along the way?
  what if the same item is the falling tile
}

fallTile () {
  unit:
  1. initialize speed
  2. update y position
  3. update to new tile grid
  4. 
}







_________________________________________________________________________________
v   Fix the blurry svg image. it's my fucking browser zoom that makes it blurry.
    I think i need to use e.PageX instead of e.offsetX. 

1. Should i use just one level unordered Array instead of tileGrid? 
2. I probably consider checking tile for click only based on cursor coordinates rather than tile grid (reason: click accuracy)
3. When do we use tuple in javascript? 
4. How do we abstracts grouped tile?




activeTile, fallingTile, and combiningTile can provide some conflict.
examples:
1. i need to handle if the tile stack is fall above the activeTile.. 
2. click on combining tile



falling of single tile

initialize speedY
calculateNewYPosition
get row based on bottom part oftile
if row position changed
  if previous row position is not bottom Free and y position exceeding tile below it
    falling process stopped
  else 
    detachFromGrid
    attachToNewGrid
    dont forget to change row tile row position (or probably already handled in attachTONEwGridFn)



3 types of combining tile
1. active combining
2. indirect active
3. passive combining (fall) 

do we really need of activeTile checking in checkTileMoveability methods?
we need to check for falling tile after the combine tile (combined while falling) touch ground


